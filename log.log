(1) strace ./main:
execve("./main", ["./main"], 0x7fff68936a80 /* 66 vars */) = 0
exit(0)                                 = ?
+++ exited with 0 +++

1- execve() system call was called
2- ./main is the path of the program being executed
3- ["./main"] is the arguments that were passed to the program
4- 0x7fff68936a80 /* 66 vars */ is the environment of the program
5- 0 is the exit status of the program
6- +++ exited +++ imply the program terminated successfully.

(2) file ./main:
./main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
1- The file is an ELF 64-bit LSB executable file
2- `version 1 (SYSV) means the file is using the SYstem V ABI
3- `statically linked` The file does no depend on any shared libraries
4- `not stripped` The symbols in the file have no been removed


note 1: just remember to always have the function epilogs and prologs:
my_function
    push rbp
    mov rbp, rsp

    sub rsp, N
    [...]

    add rsp, n
    pop rbp
    ret
To further elaborate:
- function epilogs/prologs refere to specifc parts of a function's code that are responsible for setting up and tearing down the function's stack frame.
- Function Prolog is the initial part of a function where the necessary setup is performed before executing the main body of the function, x86, the typical function prolog consists of:
1-Pushing the value of the base pointer 'rbp' onto the stack: `push rbp`
2-Setting the base pointer 'rbp' to the value of the stack pointer 'rsp': `move rbp, rsp`. This establishes a new base pointer that will be used as a reference point within the function.
After executing these steps, the function's stack frame is set up, and the function body can begin. The purpose of these actions is to ensure that the function has a consistent frame of reference for accessing local variables, function args, and handling stack-related operations.
-Function Epilog is the concluding part of a function that restores the state of the stack and prepares for returning control to the calling function:
1-Restoring the base pointer 'rbp' to its original value by popping it from the stack:'pop rbp'
This action reverts the base pointer to the value it had before the function prolog.
2-Returning control to the calling function: 'ret'
This instruction transfers the program execution back to the caller, indicating the end of the function.
The function epilog ensures that the stack is properly cleaned up and that the calling function can continue its execution seamlessly.
Overall, function prologs and epilogs play crucial roles in managing the stack frame and preserving the integrity of the program's execution flow.

note 2:
- Always use the standard function prologs and epilogs
- Always increment/decrement `rsp` by a multiple of 16.
- Address items on the stack relative to `rsp` i.e. `mov BYTE [rsp + 4], 'o'`
- If we have to decrement `rsp` by a value that's unknown at compile time(similar to how alloca() works in C), you can `and rsp, -16` to 16 bytes align it.

note 3:
we can connect to the server with `connect(2)` system call. we add our standard function prolog and epilog.
The error checking is very simplistic: we only check that the return value of the system call (in rax) is what we expect, otherwise we exit the program with a non-zero code by jumping to the `die` section
`jle` is a conditional jump which inspects global flags, hopefully set just before with `cmp` or `test`, and jumps to a label if the condition is true. for example: we compare the returned value with 0, and if it is lower or equal to 0, we jump to the error label. That's how we implement conditionals and loops.
We will store everything in this program on the stack. And since we have 8MiB of it(according to `limit`), it'll be plenty enough. in fact, the most space we need on the stack in this program will be 32KiB.
The size of the `sockaddr_un` structure is 110 bytes, so we reserve  112 to align `rsp` to 16 bytes.
we set the first 2 bytes of this structure to `AF_UNIX` since this is a domain socket.
We also want to display our window on the first monitor starting at 0, so the string is: `/tmp/.X11-unix/X0`
the way would be:
- We put the string in the `.rodata` section (same as the data section but read-only)
- We load its address in `rsi`(source)
- We load the address of the string in the structure on the stack in `rdi`(destination)
- We set `rcx` to the number of bytes to be copied
- We use `cld` to clear the `DF` flag to ensure the copy is done forwards(since it can also be done backwards)
- We call `rep movsb`
It's basically `memcpy` from C.


